import{CssChain as l}from"./CssChain.js";export function createTestTree(a){let d={light:{}};function o(e){let t=e.parentNode;t.removeChild(e);let i;e.getAttribute("data-slot-assignment")==="manual"?i=t.attachShadow({mode:e.getAttribute("data-mode"),slotAssignment:"manual"}):i=t.attachShadow({mode:e.getAttribute("data-mode")});let r=e.id;return r&&(i.id=r,d[r]=i),i.appendChild(document.importNode(e.content,!0)),i}function n(e){e.id&&(d[e.id]=e);for(let t of Array.from(e.querySelectorAll("[id]")))d[t.id]=t;for(let t of Array.from(e.querySelectorAll("template")))n(o(t))}function s(e){e.id&&(d.light[e.id]=e),l("[id]",e).map(t=>d.light[t.id]=t),l("template",e).map(t=>{const i=t.parentNode;i.removeChild(t),l(i).template(t),s(i)})}const h=(e,t)=>{let i=a.cloneNode(!0);return i.id="",i.classList.add(t),t==="light"?d.light[a.id]=i:d[a.id]=i,e.parentNode.appendChild(i),i};return n(h(a,"shadow")),s(h(a,"light")),d}export function removeWhiteSpaceOnlyTextNodes(a){for(var d=0;d<a.childNodes.length;d++){var o=a.childNodes[d];o.nodeType===Node.TEXT_NODE&&o.nodeValue.trim().length==0?(a.removeChild(o),d--):(o.nodeType===Node.ELEMENT_NODE||o.nodeType===Node.DOCUMENT_FRAGMENT_NODE)&&removeWhiteSpaceOnlyTextNodes(o)}a.shadowRoot&&removeWhiteSpaceOnlyTextNodes(a.shadowRoot)}
//# sourceMappingURL=slots-light-vs-shadow.js.map
